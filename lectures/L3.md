# Loop Functions and Debugging

## Loop Functions

**Looping on the Command Line**

Writing for, while loops is useful when programming but not particularly easy when working
interactively on the command line. There are some functions which implement looping to make
life easier.

* `lapply`: Loop over a list and evaluate a function on each element

* `sapply`: Same as `lapply` but try to simplify the result

* `apply`: Apply a function over the margins of an array

* `tapply`: Apply a function over subsets of a vector

* `mapply`: Multivariante version of `lapply`

An auxiliary function `split` is also useful, particularly in conjunction with `lapply`.

**lapply**

`lapply` takes three arguments: (1) a list `x`; (2) a function (or the name of a function) `FUN`;
(3) other arguments via its ... argument. If `x` is not a list, it will be coereced to a list using
`as.list`

`lapply` always returns a list, regardless of the class of the input.

`lapply` and friends make heavy use of anonymous functions.

An anonymous function for extracting the first column of each matrix.

**sapply**

`sapply` will try to simplify the result of `lapply` if possible.

* If the result is a list where every element is length 1, then a vector is returned

* If the result is a list where every element is a vector of the same length (>1), a matrix is returned 

* If it can not figure things out, a list is returned

**apply**

`apply` is used to evaluate a function (often an anonymous one) over the margins of an array.

* It is most often used to apply a function to the rows or columns of a matrix

* It can be used with general array, e.g. taking the average of an array of matrices

* It is not really faster than writing a loop, but it works in one line

```
> str(apply)
function (X, MARGIN, FUN, ...)
```

* `X` is an array

* `MARGIN` is an integer vector indicating which margins should be "retained"

* `FUN` is a function to be applied

* ... is for other arguments to be passed to `FUN`

**col/row sums and means**

For sums and means of matrix dimensions, we have some shortcuts.

* `rowSums = apply(x, 1, sum)`

* `rowMeans = apply(x, 1, mean)`

* `colSums = apply(x, 2, sum)`

* `colMeans = apply(x, 2, mean)`

The shortcut functions are much faster, but you won't notice unless you are using a large matrix.

**Other Ways to Apply**

Quantiles of the rows of a matrix

**mapply**

`mapply` is a multivariante apply of sorts which applies a function in parallel over a set of arguments.

```
> str(mapply)
function (FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE)
```

* `FUN` is a function to apply**

* ... contains arguments to apply over

* `MoreArgs` is a list of other arguments to `FUN`

* `SIMPLIFY` indicates whether the result should be simplified

The following is tedious to type

```
list(rep(1, 4), rep(2, 3), rep(3, 2), rep(4,1)) 
```

Instead we can do

```
> mapply(rep, 1:4, 4:1)
```


**tapply**

`tapply` is used to apply a function over subsets of a vector.

```
>str(tapply)
function (X, INDEX, FUN = NULL, ..., simplify = TRUE)
```

* `X` is a vector

* `INDEX` is a factor or a list of factors (or else they are coereced to factors)

* `FUN` is a function to be applied

* ... contains other arguments to be passed `FUN`

* `simplify`, should we simplify the result?

**split**

`split` takes a vector or other objects and splits it into groups determined by a factor or list of factors.

```
> str(split)
function (x, f, drop = FALSE, ...)
```

* `X` is a vector (or list) or data frame

* `f` is a factor (or coereced to one) or a list of factors

* `drop` indicates whether empty factors levels should be dropped

## Debugging Tools

**Diagnosing the Problem**

Indications that something's not right

* `message`: A generic notification/diagnostic message produced by the `message` function; execution of the function
continues

* `warning`: An indication that something is wrong but not necessarily fatal; execution of the function continues;
generated by the `warning` function

* `error`: An indication that a fatal problem has occurred; execution stops; produced by the `stop` function

* `condition`: A generic concept for indicating that something unexpected can occur; programmers can creat their
own conditions

How do you know that something is wrong with your function?

* What was your input? How did you call the function?

* What were you expecting? Output, messages, other results?

* What did you get?

* How does what you get differ from what you were expecting?

* Were your expectations correct in the first place?

* Can you reproduce the problem (exactly)?

**Debugging Tools in R**

The primary tools for debugging functions in R are

* `traceback`: prints out the function call stack after an error occurs; does nothing if there is no error

* `debug`: flags a function for "debug" mode which allows you to step though execution of a function one line
at a time

* `browser`: suspends the execution of a function wherever it is called and puts the function in debug mode

* `trace`: allows you to insert debugging code into a function a specific places

* `recover`: allows you to modify the error behavior so that you can browse the function call stack

These are interactive tools specifically designed to allow you to pick through a function. There is also
the more blunt technique of inserting print/cat statements in the function.

**Summary**

* There are three main indications of a problem/condition: `message`, `warning`, `error`. Only an `error` is fatal

* When analyzing a function with a problem, make sure you can reproduce the problem, clearly state your expectations
and how the output differs from your expectation

* Interactive debugging tool `traceback`, `debug`, `browser`, `trace` and `recover` can be used to find problematic
code in functions

* Debugging tools are not a substitute for thinking!










































































